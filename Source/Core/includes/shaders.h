#pragma once

namespace Shader
{
   struct CachedPipeline
   {
      // Orignal pipeline (in DX9/10/11 it's just a ptr to a shader object, in DX12 to a PSO)
      reshade::api::pipeline pipeline;
      // Cached device (makes it easier to access, even if there's usually only a global one in games (e.g. Prey))
      reshade::api::device* device;
      reshade::api::pipeline_layout layout; // DX12 stuff
      // Cloned subojects from the orignal pipeline (e.g. for shaders, this is their code/blob)
      reshade::api::pipeline_subobject* subobjects_cache;
      // Always 1 if not in DX12
      uint32_t subobject_count;
      // True if we cloned it and "replaced" it with custom shaders
      bool cloned = false;
      reshade::api::pipeline pipeline_clone;
      // Original shaders hash (there should only be one except in DX12)
#if DX12
      std::vector<uint32_t> shader_hashes;
#else
      std::array<uint32_t, 1> shader_hashes;
#endif

#if DEVELOPMENT
      // If true, this pipeline is going to skip drawing (this might draw black or leave the previous target textures value persisting)
      bool skip = false;

      struct RedirectData
      {
			enum class RedirectSourceType : uint8_t
         {
            None = 0,
            SRV = 1,
            UAV = 2,
         };
         RedirectSourceType source_type = RedirectSourceType::None;
         int source_index = 0;
         enum class RedirectTargetType : uint8_t
         {
            None = 0,
            RTV = 1,
            UAV = 2,
         };
         RedirectTargetType target_type = RedirectTargetType::None;
         int target_index = 0;
      } redirect_data;

      // Reflections data:
      // Render Target Views
      bool rtvs[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT] = {};
      // Shader Resource Views
      bool srvs[D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT] = {};
      // Unordered Access Views
      bool uavs[D3D11_1_UAV_SLOT_COUNT] = {};
#endif

      bool HasGeometryShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::geometry_shader) return true;
         }
         return false;
      }
      bool HasVertexShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::vertex_shader) return true;
         }
         return false;
      }
      bool HasPixelShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::pixel_shader) return true;
         }
         return false;
      }
      bool HasComputeShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::compute_shader) return true;
         }
         return false;
      }
   };

   struct CachedShader
   {
      void* data = nullptr; // Shader binary, allocated by this
      size_t size = 0;
      reshade::api::pipeline_subobject_type type;
      int32_t index = -1;
      std::string disasm;
   };

   struct CachedCustomShader
   {
      std::vector<uint8_t> code;
      bool is_hlsl = false;
      bool is_global = false; // If false, the shader is game specific, if true, the shader is generic/global (belonging to Luma's own shaders)
      std::filesystem::path file_path; // This should point to the source hlsl wherever possible (or a cso blob as fallback)
      std::size_t preprocessed_hash = 0; // A value of 0 won't ever be generated by the hash algorithm (this does not necessarily match the final shader binary hash)
      std::string compilation_errors; // Compilation errors and warnings log
#if DEVELOPMENT || TEST
      bool compilation_error;
      std::string preprocessed_code;
#endif
   };

   template <bool SingleShaderHashes>
   using ShaderHashesContainer = std::conditional_t<SingleShaderHashes,
      std::array<uint32_t, 1>,
      std::unordered_set<uint32_t>>;

   template <typename T>
   bool ShaderHasesContains(const std::unordered_set<T>& container, const T& value)
   {
      return container.contains(value);
   }
   template <typename T, std::size_t N>
   bool ShaderHasesContains(const std::array<T, N>& container, const T& value)
   {
      ASSERT_ONCE(container[0] != 0 || value != 0); // If both are zero, something is wrong!
      static_assert(N == 1, "Only supports std::array<T, 1>");
      return container[0] == value;
   }

   template <bool SingleShaderHashes = false>
   struct ShaderHashesList
   {
      ShaderHashesContainer<SingleShaderHashes> pixel_shaders;
      ShaderHashesContainer<SingleShaderHashes> vertex_shaders;
#if GEOMETRY_SHADER_SUPPORT
      ShaderHashesContainer<SingleShaderHashes> geometry_shaders;
#endif
      ShaderHashesContainer<SingleShaderHashes> compute_shaders;

      bool Contains(uint32_t shader_hash, reshade::api::shader_stage shader_stage) const
      {
         // NOTE: we could probably check if the value matches a specific shader stage (e.g. a switch?), but I'm not 100% sure other flags are ever set
         if ((shader_stage & reshade::api::shader_stage::pixel) != 0)
         {
            if (ShaderHasesContains(pixel_shaders, shader_hash)) return true;
         }
         if ((shader_stage & reshade::api::shader_stage::vertex) != 0)
         {
            if (ShaderHasesContains(vertex_shaders, shader_hash)) return true;
         }
#if GEOMETRY_SHADER_SUPPORT
         if ((shader_stage & reshade::api::shader_stage::geometry) != 0)
         {
            if (ShaderHasesContains(geometry_shaders, shader_hash)) return true;
         }
#endif
         if ((shader_stage & reshade::api::shader_stage::compute) != 0)
         {
            return ShaderHasesContains(compute_shaders, shader_hash);
         }
         return false;
      }
      template <bool OtherSingleShaderHashes>
      bool Contains(const ShaderHashesList<OtherSingleShaderHashes>& other) const
      {
         for (const uint32_t shader_hash : other.pixel_shaders)
         {
            if (ShaderHasesContains(pixel_shaders, shader_hash))
            {
               return true;
            }
         }
         for (const uint32_t shader_hash : other.vertex_shaders)
         {
            if (ShaderHasesContains(vertex_shaders, shader_hash))
            {
               return true;
            }
         }
#if GEOMETRY_SHADER_SUPPORT
         for (const uint32_t shader_hash : other.geometry_shaders)
         {
            if (ShaderHasesContains(geometry_shaders, shader_hash))
            {
               return true;
            }
         }
#endif
         for (const uint32_t shader_hash : other.compute_shaders)
         {
            if (ShaderHasesContains(compute_shaders, shader_hash))
            {
               return true;
            }
         }
         return false;
      }
      bool Empty() const
      {
         if constexpr (SingleShaderHashes)
         {
            return pixel_shaders[0] == 0 && vertex_shaders[0] == 0 && compute_shaders[0] == 0
#if GEOMETRY_SHADER_SUPPORT
               && geometry_shaders[0] == 0
#endif
               ;
         }
         else
         {
            // Values are expected to be non null if the array has element
            return pixel_shaders.empty() && vertex_shaders.empty() && compute_shaders.empty()
#if GEOMETRY_SHADER_SUPPORT
               && geometry_shaders.empty()
#endif
               ;
         }
      }
   };

	// Hash is meant to be 8 hex characters long (32 bits)
	// Note that these can fail to put them around a try catch if you need to handle the exception
   uint32_t Hash_StrToNum(const char* hash_hex_string)
   {
      return std::stoul(hash_hex_string, nullptr, 16);
   }
   uint32_t Hash_StrToNum(const std::string& hash_hex_string)
   {
      return std::stoul(hash_hex_string, nullptr, 16);
   }
   std::string Hash_NumToStr(uint32_t hash, bool hex_prefix = false)
   {
#if 0 // Old school method with hex prefix (upper case)
      wchar_t hash_string[11];
      swprintf_s(hash_string, L"0x%08X", hash);
#endif
      if (hex_prefix)
      {
         return std::format("{}{:08X}", "0x", hash); // Somehow formatting "0x{:08X}" directly removes the first zero from the hash string
      }
      return std::format("{:08X}", hash); // big "X" to return capital letters
   }

   // TODO: add this around the code instead of uint32_t
   struct ShaderHash
   {
      explicit ShaderHash(const std::string& str) { hash = Hash_StrToNum(str); }
      explicit ShaderHash(const char* str) { hash = Hash_StrToNum(str); }
      explicit ShaderHash(uint32_t _hash) : hash(_hash) {}

      explicit operator uint32_t() const { return hash; }

      std::string ToString(bool hex_prefix = false) const { return Hash_NumToStr(hash, hex_prefix); }

      uint32_t hash;
   };
}