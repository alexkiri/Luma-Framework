#pragma once

namespace Shader
{
   struct CachedPipeline
   {
      // Orignal pipeline
      reshade::api::pipeline pipeline;
      // Cached device (makes it easier to access, even if there's usually only a global one in games (e.g. Prey))
      reshade::api::device* device;
      reshade::api::pipeline_layout layout; // DX12 stuff
      // Cloned subojects from the orignal pipeline
      reshade::api::pipeline_subobject* subobjects_cache;
      uint32_t subobject_count;
      // True if we cloned it and "replaced" it with custom shaders
      bool cloned = false;
      reshade::api::pipeline pipeline_clone;
      // Original shaders hash (there should only be one)
      std::vector<uint32_t> shader_hashes;

#if DEVELOPMENT
      // If true, this pipeline is going to skip drawing (this might draw black or leave the previous target textures value persisting)
      bool skip = false;

      struct RedirectData
      {
			enum class RedirectSourceType : uint8_t
         {
            None = 0,
            SRV = 1,
            UAV = 2,
         };
         RedirectSourceType source_type = RedirectSourceType::None;
         int source_index = 0;
         enum class RedirectTargetType : uint8_t
         {
            None = 0,
            RTV = 1,
            UAV = 2,
         };
         RedirectTargetType target_type = RedirectTargetType::None;
         int target_index = 0;
      } redirect_data;
#endif

      bool HasGeometryShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::geometry_shader) return true;
         }
         return false;
      }
      bool HasVertexShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::vertex_shader) return true;
         }
         return false;
      }
      bool HasPixelShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::pixel_shader) return true;
         }
         return false;
      }
      bool HasComputeShader() const
      {
         for (uint32_t i = 0; i < subobject_count; i++)
         {
            if (subobjects_cache[i].type == reshade::api::pipeline_subobject_type::compute_shader) return true;
         }
         return false;
      }
   };

   struct CachedShader
   {
      void* data = nullptr; // Shader binary, allocated by this
      size_t size = 0;
      reshade::api::pipeline_subobject_type type;
      int32_t index = -1;
      std::string disasm;
   };

   struct CachedCustomShader
   {
      std::vector<uint8_t> code;
      bool is_hlsl = false;
      std::filesystem::path file_path; // This should point to the source hlsl wherever possible (or a cso blob as fallback)
      std::size_t preprocessed_hash = 0; // A value of 0 won't ever be generated by the hash algorithm (this does not necessarily match the final shader binary hash)
      std::string compilation_errors; // Compilation errors and warnings log
#if DEVELOPMENT || TEST
      bool compilation_error;
      std::string preprocessed_code;
#endif
   };

   struct ShaderHashesList
   {
      std::unordered_set<uint32_t> pixel_shaders;
      std::unordered_set<uint32_t> vertex_shaders;
#if GEOMETRY_SHADER_SUPPORT
      std::unordered_set<uint32_t> geometry_shaders;
#endif
      std::unordered_set<uint32_t> compute_shaders;

      bool Contains(uint32_t shader_hash, reshade::api::shader_stage shader_stage) const
      {
         // NOTE: we could probably check if the value matches a specific shader stage (e.g. a switch?), but I'm not 100% sure other flags are ever set
         if ((shader_stage & reshade::api::shader_stage::pixel) != 0)
         {
            if (pixel_shaders.contains(shader_hash)) return true;
         }
         if ((shader_stage & reshade::api::shader_stage::vertex) != 0)
         {
            if (vertex_shaders.contains(shader_hash)) return true;
         }
#if GEOMETRY_SHADER_SUPPORT
         if ((shader_stage & reshade::api::shader_stage::geometry) != 0)
         {
            if (geometry_shaders.contains(shader_hash)) return true;
         }
#endif
         if ((shader_stage & reshade::api::shader_stage::compute) != 0)
         {
            return compute_shaders.contains(shader_hash);
         }
         return false;
      }
      bool Contains(const ShaderHashesList& other) const
      {
         for (const uint32_t shader_hash : other.pixel_shaders)
         {
            if (pixel_shaders.contains(shader_hash))
            {
               return true;
            }
         }
         for (const uint32_t shader_hash : other.vertex_shaders)
         {
            if (vertex_shaders.contains(shader_hash))
            {
               return true;
            }
         }
#if GEOMETRY_SHADER_SUPPORT
         for (const uint32_t shader_hash : other.geometry_shaders)
         {
            if (geometry_shaders.contains(shader_hash))
            {
               return true;
            }
         }
#endif
         for (const uint32_t shader_hash : other.compute_shaders)
         {
            if (compute_shaders.contains(shader_hash))
            {
               return true;
            }
         }
         return false;
      }
      bool Empty() const
      {
         return pixel_shaders.empty() && vertex_shaders.empty() && compute_shaders.empty()
#if GEOMETRY_SHADER_SUPPORT
            && geometry_shaders.empty()
#endif
            ;
      }
   };

	// Hash is meant to be 8 hex characters long (32 bits)
	// Note that these can fail to put them around a try catch if you need to handle the exception
   uint32_t Hash_StrToNum(const char* hash_hex_string)
   {
      return std::stoul(hash_hex_string, nullptr, 16);
   }
   uint32_t Hash_StrToNum(const std::string& hash_hex_string)
   {
      return std::stoul(hash_hex_string, nullptr, 16);
   }
   std::string Hash_NumToStr(uint32_t hash, bool hex_prefix = false)
   {
#if 0 // Old school method with hex prefix (upper case)
      wchar_t hash_string[11];
      swprintf_s(hash_string, L"0x%08X", hash);
#endif
      if (hex_prefix)
      {
         return std::format("{}{:08X}", "0x", hash); // Somehow formatting "0x{:08X}" directly removes the first zero from the hash string
      }
      return std::format("{:08X}", hash); // big "X" to return capital letters
   }

   // TODO: add this around the code instead of uint32_t
   struct ShaderHash
   {
      explicit ShaderHash(const std::string& str) { hash = Hash_StrToNum(str); }
      explicit ShaderHash(const char* str) { hash = Hash_StrToNum(str); }
      explicit ShaderHash(uint32_t _hash) : hash(_hash) {}

      explicit operator uint32_t() const { return hash; }

      std::string ToString(bool hex_prefix = false) const { return Hash_NumToStr(hash, hex_prefix); }

      uint32_t hash;
   };
}